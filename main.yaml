esphome:
  name: ${name}
  on_boot:
    priority: 500
    then:
      - delay: 66ms
      - if:
          condition:
            binary_sensor.is_on: zone_input
          then:
            - script.execute:
                id: set_effect
                type: restore
                mode: set
            - switch.turn_on: shunt
          else:
            - script.execute:
                id: set_effect
                type: restore
                mode: restore
            - if:
                condition:
                  binary_sensor.is_on: presignal_input
                then:
                  - script.execute: set_presignal

esp32:
  board: esp32doit-devkit-v1
  #board: esp32dev
  framework:
    type: esp-idf

external_components:
  - source:
      type: local
      path: components
    components: [sequencer]

sequencer:

text_sensor:
  - platform: template
    name: "Current Effect"
    id: "current_effect"

  - platform: template
    name: "Set Effect"
    id: status_effect

  - platform: template
    name: "Set Effect Type"
    id: status_effect_type

button:
  - platform: safe_mode
    name: Safe Mode Boot
    entity_category: diagnostic

  - name: Fire Up
    id: fire_up
    platform: template
    on_press:
      - script.execute:
          id: set_effect
          mode: up
          type: fire

  - name: Fire Down
    id: fire_down
    platform: template
    on_press:
      - script.execute:
          id: set_effect
          mode: down
          type: fire

  - name: March Up
    id: march_up
    platform: template
    on_press:
      - script.execute:
          id: set_effect
          type: march
          mode: up

  - name: March Down
    id: march_down
    platform: template
    on_press:
      - script.execute:
          id: set_effect
          type: march
          mode: down

  - name: Code Up
    id: code_up
    platform: template
    on_press:
      - script.execute:
          id: set_effect
          type: code
          mode: up

  - name: Code Down
    id: code_down
    platform: template
    on_press:
      - script.execute:
          id: set_effect
          type: code
          mode: down

output:
  - platform: gpio
    pin: ${gpio_code}
    id: gpio_code

  - platform: gpio
    pin: ${gpio_led}
    id: gpio_led
    inverted: ${gpio_led_invert}

  # Template output that mirrors to LED
  - platform: template
    id: code_output
    type: binary
    write_action:
      - if:
          condition:
            lambda: 'return state;'
          then:
            - output.turn_on: gpio_code
            - output.turn_on: gpio_led
          else:
            - output.turn_off: gpio_code
            - output.turn_off: gpio_led

switch:
  - name: Toggle
    id: toggle
    platform: template
    lambda: 'return (id(shunt).state);'
    turn_on_action:
      - if:
          condition:
            binary_sensor.is_on: presignal_input
          then:
            - script.execute: set_presignal
          else:
            - script.execute:
                id: set_effect
                type: restore
                mode: set
            - delay: 66ms
            - switch.turn_on: shunt
    turn_off_action:
      - if:
          condition:
            binary_sensor.is_on: in_presignal
          then:
            - script.execute:
                id: set_effect
                type: restore
                mode: set
          else:
            - light.turn_off: code

  - platform: gpio
    pin: ${gpio_reverse}
    id: reverse
    name: reverse
    on_turn_on:
      - if:
          condition:
            lambda: 'return id(code).get_effect_name() == "None";'
          then:
            - delay: 5000ms
            - switch.turn_off: reverse

  - platform: gpio
    pin: ${gpio_shunt}
    id: shunt
    name: shunt
    on_turn_on:
      - if:
          condition:
            lambda: 'return id(code).get_effect_name() == "None";'
          then:
            - delay: 5000ms
            - switch.turn_off: shunt

  - platform: gpio
    pin: ${gpio_trigger}
    id: trigger
    name: trigger
    on_turn_on:
      - if:
          condition:
            lambda: 'return id(code).get_effect_name() == "None";'
          then:
            - delay: 5000ms
            - switch.turn_off: trigger

light:
  - platform: binary
    output: code_output
    id: code
    name: code
    on_state:
      - text_sensor.template.publish:
          id: current_effect
          state: !lambda 'return id(code).get_effect_name();'

      - if:
          condition:
            lambda: 'return id(code).get_effect_name() == "None" && ! id(code).current_values.is_on();'
          then:
            - switch.turn_off: shunt
            - switch.turn_off: reverse
            - switch.turn_off: trigger
            - globals.set:
                id: alarm_active
                value: 'false'
            - globals.set:
                id: presignal_active
                value: 'false'

      - delay: 10ms
      - if:
          condition:
            lambda: 'return id(code).get_effect_name() == "None" && id(code).current_values.is_on();'
          then:
            - delay: 5000ms
            - light.turn_off: code
    effects:
      - lambda:
          name: 'On'
          update_interval: 250ms
          lambda: ''

      - lambda:
          name: 'Off'
          update_interval: 250ms
          lambda: |-
            id(code_output).turn_off();

      - march:
          name: March 20
          output: code_output
          on_ms: 1500

      - march:
          name: March 30
          output: code_output
          on_ms: 1000

      - march:
          name: March 60
          output: code_output
          on_ms: 500

      - march:
          name: March 90
          output: code_output
          on_ms: 333

      - march:
          name: March 100
          output: code_output
          on_ms: 300

      - march:
          name: March 120
          output: code_output
          on_ms: 250

      - march:
          name: March 150
          output: code_output
          on_ms: 200

      - march:
          name: March 180
          output: code_output
          on_ms: 166

      - march:
          name: March 200
          output: code_output
          on_ms: 150

      - march:
          name: March 250
          output: code_output
          on_ms: 120

      - march:
          name: March 300 / Steady T4
          output: code_output
          on_ms: 100

      - step_seq:
          name: March 150 Fun
          output: code_output
          step_ms: 66
          # 7 slow cycles (3 on, 3 off) + 3 fast cycles (1 on, 1 off)
          pattern: ".--   .--   .--   .--   .--   .--   .--   . . . "

      - step_seq:
          name: Four On The Floor
          output: code_output
          step_ms: 125
          # Classic disco/house - steady quarter notes
          pattern: ".   .   .   .   "

      - step_seq:
          name: Boots N Cats
          output: code_output
          step_ms: 100
          # boots-n-cats-n-boots-n-cats
          pattern: ".-- . .-- . "

      - step_seq:
          name: Breakbeat
          output: code_output
          step_ms: 80
          # Amen break style
          pattern: ".  .. .  . .. . "

      - step_seq:
          name: Syncopation
          output: code_output
          step_ms: 100
          # Off-beat funk
          pattern: ". ..  . . ..  . "

      - step_seq:
          name: Gallop
          output: code_output
          step_ms: 80
          # Metal gallop rhythm
          pattern: ".  . ..  . ."

      - step_seq:
          name: SOS
          output: code_output
          step_ms: 100
          # ... --- ... (morse code)
          pattern: ". . .   .-- .-- .--   . . .       "

      - step_seq:
          name: XERO
          output: code_output
          step_ms: 100
          # -..- . .-. --- (morse code)
          pattern: ".-- . . .--   .   . .-- .   .-- .-- .--       "

      - march:
          name: Standard March
          output: code_output
          on_ms: 150
          off_ms: 400

      - march:
          name: PreSignal
          output: code_output
          on_ms: 100
          off_ms: 3000

      - march:
          name: California Code
          output: code_output
          on_ms: 10000
          off_ms: 5000

      - fire_code:
          name: Pulsed California Code
          output: code_output
          pattern: "20"
          pulse_ms: 250
          cycle_gap_ms: 5000

      - fire_code:
          name: 4-4
          output: code_output
          pattern: "4 4"
          pulse_ms: 250

      - fire_code:
          name: 4-4-4-4
          output: code_output
          pattern: "4 4 4 4"
          pulse_ms: 250

      - fire_code:
          name: Jingle Bells
          output: code_output
          pattern: "3 3 5"
          pulse_ms: 250
          group_gap_ms: 750
          cycle_gap_ms: 1750

      - fire_code:
          name: Temporal 3
          output: code_output
          pattern: "3"
          pulse_ms: 500
          cycle_gap_ms: 1500

      - fire_code:
          name: Temporal 4
          output: code_output
          pattern: "4"
          pulse_ms: 100

      - fire_code:
          name: Temporal 2
          output: code_output
          pattern: "2"
          pulse_ms: 115
          cycle_gap_ms: 575

      - march:
          name: Federal Signal Siren
          output: code_output
          on_ms: 6000
          off_ms: 6000

      - march:
          name: Fast Wail
          output: code_output
          on_ms: 2000
          off_ms: 2000

globals:
 - id: alarm_active
   type: bool
   restore_value: no
   initial_value: 'false'

 - id: presignal_active
   type: bool
   restore_value: no
   initial_value: 'false'

 - id: effect_type
   type: short
   restore_value: yes
   initial_value: '0'


 - id: effect
   type: short
   restore_value: yes
   initial_value: '0'

 - id: fire_effects
   type: std::vector<std::string>
   initial_value: '{
     "On",
     "Temporal 2",
     "Temporal 3",
     "Temporal 4",
     "California Code",
     "Pulsed California Code",
     "4-4",
     "4-4-4-4",
     "Off"
   }'

 - id: march_effects
   type: std::vector<std::string>
   initial_value: '{
     "PreSignal",
     "March 20",
     "March 30",
     "March 60",
     "March 90",
     "March 100",
     "March 120",
     "March 150",
     "March 180",
     "March 200",
     "March 250",
     "March 300 / Steady T4",
     "Standard March",
     "March 150 Fun"
   }'

 - id: code_effects
   type: std::vector<std::string>
   initial_value: '{
     "Jingle Bells",
     "Federal Signal Siren",
     "Fast Wail",
     "Four On The Floor",
     "Boots N Cats",
     "Breakbeat",
     "Syncopation",
     "Gallop",
     "SOS",
     "XERO"
   }'

 - id: doorbell_effects
   type: std::vector<std::string>
   restore_value: no
   initial_value: 'std::vector<std::string>{}'

script:
  - id: set_effect
    parameters:
      type: std::string
      mode: std::string
    then:
      - lambda: |-
          id(reverse).turn_off();
          id(trigger).turn_off();

          struct effects {
            int id;
            std::string type;
            std::vector<std::string> list;
          };

          effects effects_map[] {
            { 0, "fire", id(fire_effects) },
            { 1, "march", id(march_effects) },
            { 2, "code", id(code_effects) },
            { 3, "doorbell", id(doorbell_effects) }
          };

          effects effect_map;

          for ( auto value : effects_map ){
            if (type == value.type || (type == "restore" && id(effect_type) == value.id )) {
              effect_map = value;
              break;
            }
          }

          // Safety check: fallback to fire_effects if list is empty
          if (effect_map.list.empty()) {
            effect_map = { 0, "fire", id(fire_effects) };
          }

          int next_id;

          bool not_found = (id(effect_type) == effect_map.id && id(effect) < (int)effect_map.list.size())
            ? find(effect_map.list.begin(), effect_map.list.end(), effect_map.list[id(effect)]) == effect_map.list.end()
            : true;

          if (mode == "down" && (not_found || id(effect) - 1 < 0)) {
            next_id = effect_map.list.size() - 1;
          } else if (mode == "down") {
            next_id = id(effect) - 1;
          } else if (mode == "up" && (not_found || id(effect) + 1 >= (int)effect_map.list.size())) {
            next_id = 0;
          } else if (mode == "up") {
            next_id = id(effect) + 1;
          } else {
            next_id = id(effect);
          }

          // Bounds check next_id
          if (next_id < 0 || next_id >= (int)effect_map.list.size()) {
            next_id = 0;
          }

          std::string next_effect = effect_map.list[next_id];
          //ESP_LOGD("status", "set_effect - type: %s - mode: %s - list size: %i - item %s - effect: %s", type.c_str(), mode.c_str(), effect_map.list.size(), not_found ? "not found" : "found", next_effect.c_str());

          if (mode != "restore") {
            auto call = id(code).turn_on();
            call.set_effect(next_effect);
            call.perform();
            id(alarm_active) = true;
          }

          id(effect_type) = effect_map.id;
          id(effect) = next_id;
          id(status_effect).publish_state(next_effect);
          id(status_effect_type).publish_state(effect_map.type);

  - id: set_presignal
    then:
      - light.turn_on:
          id: code
          effect: PreSignal
      - switch.turn_on: shunt
      - globals.set:
          id: presignal_active
          value: 'true'

binary_sensor:
  - name: In Alarm
    id: in_alarm
    platform: template
    lambda: 'return (id(alarm_active) && id(shunt).state);'
    on_press:
      - globals.set:
          id: presignal_active
          value: 'false'

  - name: In PreSignal
    id: in_presignal
    platform: template
    lambda: 'return (id(presignal_active) && id(shunt).state);'

  - name: PreSignal Input
    id: presignal_input
    platform: gpio
    pin:
      number: ${gpio_presignal}
      inverted: ${gpio_presignal_invert}
      mode:
        input: true
    filters:
      - delayed_on: 10ms
      - delayed_off: 100ms
    on_press:
      - if:
          condition:
            binary_sensor.is_off: zone_input
          then:
            - script.execute: set_presignal
    on_release:
      - if:
          condition:
            binary_sensor.is_off: zone_input
          then:
            - light.turn_off: code

  - name: Zone Input
    id: zone_input
    platform: gpio
    pin:
      number: ${gpio_zone}
      inverted: ${gpio_zone_invert}
      mode:
        input: true
        pullup: true
    filters:
      - delayed_on: 10ms
      - delayed_off: 100ms
    on_press:
      - script.execute:
          id: set_effect
          type: restore
          mode: set
      - delay: 66ms
      - switch.turn_on: shunt
    on_release:
      - light.turn_off: code

# Enable logging
logger:
    level: DEBUG
    baud_rate: 0

# Enable Home Assistant API
api:
  reboot_timeout: 0s
  encryption:
    key: !secret api_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  reboot_timeout: 0s
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
#  ap:
#    ssid: !secret wifi_portal_ssid
#    password: !secret wifi_portal_password
#
#captive_portal:
