esphome:
  name: ${name}
  on_boot:
    - priority: 500
      then:
        - delay: 66ms
        - if:
            condition:
              binary_sensor.is_on: zone_input
            then:
              - script.execute:
                  id: set_effect
                  type: restore
                  mode: set
              - switch.turn_on: shunt
            else:
              - script.execute:
                  id: set_effect
                  type: restore
                  mode: restore
              - if:
                  condition:
                    binary_sensor.is_on: presignal_input
                  then:
                    - script.execute: set_presignal

esp32:
  board: esp32doit-devkit-v1
  #board: esp32dev
  framework:
    type: esp-idf

external_components:
  - source:
      type: local
      path: components
    components: [sequencer]

sequencer:

text_sensor:
  - platform: template
    name: "Current Effect"
    id: "current_effect"

  - platform: template
    name: "Set Effect"
    id: status_effect

  - platform: template
    name: "Set Effect Type"
    id: status_effect_type

button:
  - platform: safe_mode
    name: Safe Mode Boot
    entity_category: diagnostic

  - name: Fire Up
    id: fire_up
    platform: template
    on_press:
      - script.execute:
          id: set_effect
          mode: up
          type: fire

  - name: Fire Down
    id: fire_down
    platform: template
    on_press:
      - script.execute:
          id: set_effect
          mode: down
          type: fire

  - name: March Up
    id: march_up
    platform: template
    on_press:
      - script.execute:
          id: set_effect
          type: march
          mode: up

  - name: March Down
    id: march_down
    platform: template
    on_press:
      - script.execute:
          id: set_effect
          type: march
          mode: down

  - name: Code Up
    id: code_up
    platform: template
    on_press:
      - script.execute:
          id: set_effect
          type: code
          mode: up

  - name: Code Down
    id: code_down
    platform: template
    on_press:
      - script.execute:
          id: set_effect
          type: code
          mode: down

output:
  - platform: gpio
    pin: ${gpio_code}
    id: gpio_code

  - platform: gpio
    pin: ${gpio_led}
    id: gpio_led
    inverted: ${gpio_led_invert}

  # Template output that mirrors to LED
  - platform: template
    id: code_output
    type: binary
    write_action:
      - if:
          condition:
            lambda: 'return state;'
          then:
            - output.turn_on: gpio_code
            - output.turn_on: gpio_led
          else:
            - output.turn_off: gpio_code
            - output.turn_off: gpio_led

switch:
  - name: Toggle
    id: toggle
    platform: template
    lambda: 'return (id(shunt).state);'
    turn_on_action:
      - if:
          condition:
            binary_sensor.is_on: presignal_input
          then:
            - script.execute: set_presignal
          else:
            - script.execute:
                id: set_effect
                type: restore
                mode: set
            - delay: 66ms
            - switch.turn_on: shunt
    turn_off_action:
      - if:
          condition:
            binary_sensor.is_on: in_presignal
          then:
            - script.execute:
                id: set_effect
                type: restore
                mode: set
          else:
            - light.turn_off: code

  - platform: gpio
    pin: ${gpio_reverse}
    id: reverse
    name: reverse
    on_turn_on:
      - if:
          condition:
            lambda: 'return id(code).get_effect_name() == "None";'
          then:
            - delay: 5000ms
            - switch.turn_off: reverse

  - platform: gpio
    pin: ${gpio_shunt}
    id: shunt
    name: shunt
    on_turn_on:
      - if:
          condition:
            lambda: 'return id(code).get_effect_name() == "None";'
          then:
            - delay: 5000ms
            - switch.turn_off: shunt

  - platform: gpio
    pin: ${gpio_trigger}
    id: trigger
    name: trigger
    on_turn_on:
      - if:
          condition:
            lambda: 'return id(code).get_effect_name() == "None";'
          then:
            - delay: 5000ms
            - switch.turn_off: trigger

light:
  - platform: binary
    output: code_output
    id: code
    name: code
    on_state:
      - text_sensor.template.publish:
          id: current_effect
          state: !lambda 'return id(code).get_effect_name();'

      - if:
          condition:
            lambda: 'return id(code).get_effect_name() == "None" && ! id(code).current_values.is_on();'
          then:
            - switch.turn_off: shunt
            - switch.turn_off: reverse
            - switch.turn_off: trigger
            - globals.set:
                id: alarm_active
                value: 'false'
            - globals.set:
                id: presignal_active
                value: 'false'

      - delay: 10ms
      - if:
          condition:
            lambda: 'return id(code).get_effect_name() == "None" && id(code).current_values.is_on();'
          then:
            - delay: 5000ms
            - light.turn_off: code
globals:
 - id: alarm_active
   type: bool
   restore_value: no
   initial_value: 'false'

 - id: presignal_active
   type: bool
   restore_value: no
   initial_value: 'false'

 - id: effect_type
   type: short
   restore_value: yes
   initial_value: '0'


 - id: effect
   type: short
   restore_value: yes
   initial_value: '0'

 - id: fire_effects
   type: std::vector<std::string>
   restore_value: no
   initial_value: 'std::vector<std::string>{}'

 - id: march_effects
   type: std::vector<std::string>
   restore_value: no
   initial_value: 'std::vector<std::string>{}'

 - id: code_effects
   type: std::vector<std::string>
   restore_value: no
   initial_value: 'std::vector<std::string>{}'

 - id: doorbell_effects
   type: std::vector<std::string>
   restore_value: no
   initial_value: 'std::vector<std::string>{}'

script:
  - id: set_effect
    parameters:
      type: std::string
      mode: std::string
    then:
      - lambda: |-
          id(reverse).turn_off();
          id(trigger).turn_off();

          struct effects {
            int id;
            std::string type;
            std::vector<std::string> list;
          };

          effects effects_map[] {
            { 0, "fire", id(fire_effects) },
            { 1, "march", id(march_effects) },
            { 2, "code", id(code_effects) },
            { 3, "doorbell", id(doorbell_effects) }
          };

          effects effect_map;

          for ( auto value : effects_map ){
            if (type == value.type || (type == "restore" && id(effect_type) == value.id )) {
              effect_map = value;
              break;
            }
          }

          // Safety check: fallback to fire_effects if list is empty
          if (effect_map.list.empty()) {
            effect_map = { 0, "fire", id(fire_effects) };
          }

          // If still empty, bail out - no effects available for this type
          if (effect_map.list.empty()) {
            ESP_LOGW("set_effect", "No effects available for type: %s", type.c_str());
            return;
          }

          int next_id;

          bool not_found = (id(effect_type) == effect_map.id && id(effect) < (int)effect_map.list.size())
            ? find(effect_map.list.begin(), effect_map.list.end(), effect_map.list[id(effect)]) == effect_map.list.end()
            : true;

          if (mode == "down" && (not_found || id(effect) - 1 < 0)) {
            next_id = effect_map.list.size() - 1;
          } else if (mode == "down") {
            next_id = id(effect) - 1;
          } else if (mode == "up" && (not_found || id(effect) + 1 >= (int)effect_map.list.size())) {
            next_id = 0;
          } else if (mode == "up") {
            next_id = id(effect) + 1;
          } else {
            next_id = id(effect);
          }

          // Bounds check next_id
          if (next_id < 0 || next_id >= (int)effect_map.list.size()) {
            next_id = 0;
          }

          std::string next_effect = effect_map.list[next_id];
          //ESP_LOGD("status", "set_effect - type: %s - mode: %s - list size: %i - item %s - effect: %s", type.c_str(), mode.c_str(), effect_map.list.size(), not_found ? "not found" : "found", next_effect.c_str());

          if (mode != "restore") {
            auto call = id(code).turn_on();
            call.set_effect(next_effect);
            call.perform();
            id(alarm_active) = true;
          }

          id(effect_type) = effect_map.id;
          id(effect) = next_id;
          id(status_effect).publish_state(next_effect);
          id(status_effect_type).publish_state(effect_map.type);

  - id: set_presignal
    then:
      - light.turn_on:
          id: code
          effect: PreSignal
      - switch.turn_on: shunt
      - globals.set:
          id: presignal_active
          value: 'true'

binary_sensor:
  - name: In Alarm
    id: in_alarm
    platform: template
    lambda: 'return (id(alarm_active) && id(shunt).state);'
    on_press:
      - globals.set:
          id: presignal_active
          value: 'false'

  - name: In PreSignal
    id: in_presignal
    platform: template
    lambda: 'return (id(presignal_active) && id(shunt).state);'

  - name: PreSignal Input
    id: presignal_input
    platform: gpio
    pin:
      number: ${gpio_presignal}
      inverted: ${gpio_presignal_invert}
      mode:
        input: true
    filters:
      - delayed_on: 10ms
      - delayed_off: 100ms
    on_press:
      - if:
          condition:
            binary_sensor.is_off: zone_input
          then:
            - script.execute: set_presignal
    on_release:
      - if:
          condition:
            binary_sensor.is_off: zone_input
          then:
            - light.turn_off: code

  - name: Zone Input
    id: zone_input
    platform: gpio
    pin:
      number: ${gpio_zone}
      inverted: ${gpio_zone_invert}
      mode:
        input: true
        pullup: true
    filters:
      - delayed_on: 10ms
      - delayed_off: 100ms
    on_press:
      - script.execute:
          id: set_effect
          type: restore
          mode: set
      - delay: 66ms
      - switch.turn_on: shunt
    on_release:
      - light.turn_off: code

# Enable logging
logger:
    level: DEBUG
    baud_rate: 0

# Enable Home Assistant API
api:
  reboot_timeout: 0s
  encryption:
    key: !secret api_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  reboot_timeout: 0s
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
#  ap:
#    ssid: !secret wifi_portal_ssid
#    password: !secret wifi_portal_password
#
#captive_portal:
