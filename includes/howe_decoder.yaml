# Howe Transmitter Decoder
# Decodes pulse codes from Autocall-Howe fire alarm transmitters
#
# Requires substitutions:
#   gpio_howe_oscillator: GPIO for oscillator/timer relay input
#   gpio_howe_signal: GPIO for signal line input
#
# Hardware setup:
#   - IMPORTANT: Use PC817 optocouplers for isolation from 125VDC system
#     (without isolation, EMI from pulsing relays causes chaos - USB dropouts,
#     random device activation, etc. 125VDC pulses are no joke)
#   - Wire optocoupler outputs to pull GPIO low when active (use internal pullup)
#   - Oscillator: timer relay that pulses at ~1.9Hz during transmission
#   - Signal: pulses in sync with oscillator for "marks", silent for "spaces"
#
# Decoding strategy:
#   - Edge detection: signal rising edge sets flag, oscillator tick reads & clears it
#   - 50ms debounce filter on signal to reject glitches
#   - Only track signal edges when oscillator active (within 1 second)
#
# Gap logic (spaces between marks):
#   - 1 gap = digit separator, record accumulated mark count as digit
#   - 2 gaps = 1 blank digit (X)
#   - 3 gaps = 2 blank digits (X-X)
#   - 4+ gaps = round complete, log station code
#
# Round-robin support (multiple stations interleaving):
#   - Per-station round tracking via std::map
#   - Max-length fallback: if code exceeds 5 parts (prefix + 4 digits)
#     and ends with 2+ trailing X's, force round boundary
#   - Handles short inter-station gaps that don't hit 4-gap threshold
#
# Station code format: prefix-digit-digit-digit-digit
#   - Prefix indicates alarm type (1=watchman/fire, 2=fire, 3=supervisory, etc.)
#   - 5 rounds = alarm, 1 round = reset (typically)
#
# Output: Log with decoded codes, round counts per station, transmission summary

globals:
  # Decoder state
  - id: howe_digit_counter
    type: int
    initial_value: '0'
  - id: howe_gap_counter
    type: int
    initial_value: '0'
  - id: howe_current_code
    type: std::string
    initial_value: '""'
  - id: howe_station_counts
    type: std::map<std::string, int>
    restore_value: false  # Per-station round counts for round-robin tracking
  - id: howe_in_transmission
    type: bool
    initial_value: 'false'
  - id: howe_last_osc_time
    type: unsigned long
    initial_value: '0'
  - id: howe_signal_seen
    type: bool
    initial_value: 'false'  # Edge-triggered: was signal active since last osc tick?

binary_sensor:
  # Signal input - edge detection for reliable mark counting
  - platform: gpio
    id: howe_signal
    name: "Howe Signal"
    pin:
      number: ${gpio_howe_signal}
      mode:
        input: true
        pullup: true
      inverted: true  # Pulled low when relay closes
    filters:
      - delayed_on: 50ms   # Filter glitches <50ms, keep valid pulses
    on_press:
      - lambda: |-
          // Only track edges if oscillator is active (prevents stale signals)
          unsigned long now = millis();
          if (now - id(howe_last_osc_time) < 1000) {
            id(howe_signal_seen) = true;
          }

  # Oscillator input - this is our clock, we sample signal on each tick
  - platform: gpio
    id: howe_oscillator
    name: "Howe Oscillator"
    pin:
      number: ${gpio_howe_oscillator}
      mode:
        input: true
        pullup: true
      inverted: true  # Pulled low when relay closes
    filters:
      - delayed_on: 2ms
      - delayed_off: 2ms
    on_press:
      - lambda: |-
          unsigned long now = millis();
          unsigned long delta = now - id(howe_last_osc_time);

          // Log oscillator timing (only if reasonable interval)
          if (delta > 10 && delta < 2000) {
            ESP_LOGD("howe", "Osc tick: %lums (%.1f Hz)", delta, 1000.0 / delta);
          }

          id(howe_last_osc_time) = now;

          // For starting: use edge detection (catches first signal even if brief)
          // For counting: use level detection (filters glitches, matches protocol)
          bool signal_edge = id(howe_signal_seen);
          bool signal_level = id(howe_signal).state;
          id(howe_signal_seen) = false;  // Reset for next interval

          // Only start transmission on first actual signal (not just oscillator warmup)
          if (!id(howe_in_transmission)) {
            if (signal_edge || signal_level) {
              id(howe_in_transmission) = true;
              id(howe_current_code) = "";
              id(howe_digit_counter) = 0;
              id(howe_gap_counter) = 0;
              id(howe_station_counts).clear();  // Fresh map for this transmission
              ESP_LOGI("howe", "=== Transmission started ===");
            } else {
              // Oscillator running but no signal yet - ignore warmup pulses
              return;
            }
          }

          // Use edge detection for counting (debounce filter handles glitches)
          if (signal_edge) {
            // Mark - increment digit counter

            // But first, check if we had a gap before this
            if (id(howe_gap_counter) > 0) {
              // We had gap(s), now signal is back
              // Gap logic:
              //   1 gap  = digit separator (no blanks)
              //   2 gaps = 1 blank
              //   3 gaps = 2 blanks
              //   N gaps = (N-1) blanks
              //   4+ gaps = round separator

              if (id(howe_gap_counter) >= 4) {
                // Long gap = round complete (4+ gaps = round separator)
                if (id(howe_digit_counter) > 0) {
                  if (id(howe_current_code).length() > 0) {
                    id(howe_current_code) += "-";
                  }
                  id(howe_current_code) += to_string(id(howe_digit_counter));
                }

                // Parse prefix and station
                std::string code = id(howe_current_code);
                std::string prefix = "";
                std::string station = "";
                size_t first_dash = code.find('-');
                if (first_dash != std::string::npos) {
                  prefix = code.substr(0, first_dash);
                  station = code.substr(first_dash + 1);
                } else {
                  prefix = code;
                }

                // Increment per-station round count (handles round-robin interleaving)
                id(howe_station_counts)[code]++;
                int round = id(howe_station_counts)[code];

                ESP_LOGI("howe", "[%s] round %d (prefix=%s station=%s)",
                         code.c_str(), round, prefix.c_str(), station.c_str());

                // Reset for next round
                id(howe_current_code) = "";
              }
              else {
                // Record the previous digit if we had one
                if (id(howe_digit_counter) > 0) {
                  if (id(howe_current_code).length() > 0) {
                    id(howe_current_code) += "-";
                  }
                  id(howe_current_code) += to_string(id(howe_digit_counter));
                  ESP_LOGD("howe", "Digit: %d", id(howe_digit_counter));
                }

                // Add blanks: (gap_counter - 1) blanks
                int num_blanks = id(howe_gap_counter) - 1;
                for (int i = 0; i < num_blanks; i++) {
                  id(howe_current_code) += "-X";
                  ESP_LOGD("howe", "Blank digit");
                }

                // Check if code exceeds max length (prefix + 4 digits = 5 parts)
                // Count dashes to determine number of parts
                int dash_count = 0;
                for (char c : id(howe_current_code)) {
                  if (c == '-') dash_count++;
                }
                if (dash_count >= 5) {
                  // Code too long - check for trailing X-X (inter-station gap)
                  std::string full_code = id(howe_current_code);

                  // Count trailing X's
                  int trailing_x = 0;
                  for (int i = full_code.length() - 1; i >= 0; i--) {
                    if (full_code[i] == 'X') {
                      trailing_x++;
                    } else if (full_code[i] == '-') {
                      // Skip dashes between X's
                      continue;
                    } else {
                      break;
                    }
                  }

                  if (trailing_x >= 2) {
                    // Found inter-station gap (2+ trailing X's)
                    // Split before the trailing X's
                    ESP_LOGW("howe", "Code exceeded max length with trailing gap, forcing round boundary");

                    // Find where trailing X's start (find last non-X before them)
                    size_t split_pos = full_code.length();
                    int x_count = 0;
                    for (int i = full_code.length() - 1; i >= 0; i--) {
                      if (full_code[i] == 'X') {
                        x_count++;
                      } else if (full_code[i] == '-') {
                        continue;
                      } else {
                        // Found last non-X, split after this digit and its dash
                        split_pos = i + 1;
                        break;
                      }
                    }

                    std::string code = full_code.substr(0, split_pos);
                    // Remove trailing dash if present
                    if (code.length() > 0 && code[code.length() - 1] == '-') {
                      code = code.substr(0, code.length() - 1);
                    }

                    // Parse and log the completed code
                    std::string prefix = "";
                    std::string station = "";
                    size_t first_dash = code.find('-');
                    if (first_dash != std::string::npos) {
                      prefix = code.substr(0, first_dash);
                      station = code.substr(first_dash + 1);
                    } else {
                      prefix = code;
                    }

                    id(howe_station_counts)[code]++;
                    int round = id(howe_station_counts)[code];
                    ESP_LOGI("howe", "[%s] round %d (prefix=%s station=%s)",
                             code.c_str(), round, prefix.c_str(), station.c_str());

                    // Reset - current digit being counted is next station's prefix
                    id(howe_current_code) = "";
                  }
                }
              }

              id(howe_gap_counter) = 0;
              id(howe_digit_counter) = 0;
            }

            // Count this mark
            id(howe_digit_counter)++;
            ESP_LOGV("howe", "Mark: digit_counter=%d", id(howe_digit_counter));
          }
          else {
            // Space - increment gap counter
            id(howe_gap_counter)++;
            ESP_LOGV("howe", "Space: gap_counter=%d", id(howe_gap_counter));
          }

# Timeout check - detects end of transmission when oscillator stops
interval:
  - interval: 250ms
    then:
      - lambda: |-
          unsigned long now = millis();
          unsigned long silence = now - id(howe_last_osc_time);

          // If oscillator has been quiet for >2 seconds, transmission is over
          if (id(howe_in_transmission) && silence > 2000) {
            // Record any pending digit
            if (id(howe_digit_counter) > 0) {
              if (id(howe_current_code).length() > 0) {
                id(howe_current_code) += "-";
              }
              id(howe_current_code) += to_string(id(howe_digit_counter));
            }

            // Log final round if we have data
            if (id(howe_current_code).length() > 0) {
              std::string code = id(howe_current_code);
              std::string prefix = "";
              std::string station = "";
              size_t first_dash = code.find('-');
              if (first_dash != std::string::npos) {
                prefix = code.substr(0, first_dash);
                station = code.substr(first_dash + 1);
              } else {
                prefix = code;
              }

              // Increment per-station round count
              id(howe_station_counts)[code]++;
              int round = id(howe_station_counts)[code];

              ESP_LOGI("howe", "[%s] round %d (prefix=%s station=%s)",
                       code.c_str(), round, prefix.c_str(), station.c_str());
            }

            // Log transmission summary with all station counts
            ESP_LOGI("howe", "=== Transmission complete ===");
            for (auto& kv : id(howe_station_counts)) {
              ESP_LOGI("howe", "  Station [%s]: %d rounds", kv.first.c_str(), kv.second);
            }

            // Reset state
            id(howe_in_transmission) = false;
            id(howe_digit_counter) = 0;
            id(howe_gap_counter) = 0;
            id(howe_current_code) = "";
            id(howe_signal_seen) = false;
            id(howe_station_counts).clear();  // Clear for next transmission
          }
